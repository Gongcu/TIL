# 문제를 읽고 유형을 파악하기

## 입출력의 제한
- 100개 미만, 백트래킹, 플로이드 워셜 가능
- 10,000개 미만, O(n^)
- 1,000,000개 미만, O(nlogn) -> Heap, 다익스트라, 정렬 가능
- 100,000,000개 미만, O(n) -> DP, 그리디, 이분탐색



## 문제에서 힌트 얻기
- 그래프로 표현 가능한 경우: BFS, DFS, Dijkstra, Kruskal
- 사이클이 없고, 특정 작업이 끝나야 다른 작업이 수행 가능한 경우(순서, 차례): 위상정렬(DFS로 구현)
[link](https://www.acmicpc.net/problem/1005)
- X 조건을 만족하는 최대/최소 찾기: 이분탐색, 그리디
- 실시간으로 정렬해야 하는 경우: PriorityQueue
- 현재 상태로 다음 값을 구할 수 있는 경우: DP
- 사이클 여부 확인: Union-Find, DFS
- 문자열을 적은 시간복잡도로 찾아야 하는 경우: Trie
- 도시 A에서 시작해서 다른 모든 도시를 거쳐 다시 A로 돌아오는 최소비용: DP+Bit Mask
- 순서 찾기, 순위 찾기: 플로이드 워셜, DFS 양방향
- 특정 순서로 방문하기: 위상 정렬


## 알고리즘 한 줄 요약
- 이진 탐색: O(logn)의 시간복잡도로 조건에 만족하는 최대/최소의 경우 탐색
- 그리디: 조건에 만족하는 최대/최소의 경우 탐색. 현재 답이 다음에 영향이 없고, 현재 최적이 메인 문제의 최적
- DP: 현재 답을 이용해 다음 문제의 답을 찾을 수 있음. 조건에 맞는 최대/최소/경우의 수의 개수 등
- 백트래킹: 모든 경우의 수를 찾아 출력해야 하는 경우 사용. O(n!)의 시간복잡도 소요.
- 투 포인터: 두 개의 포인터를 사용하여 범위를 설정하는 알고리즘
- BFS: 그래프 탐색 알고리즘. 한 점에서 다른 점까지 최단 경로 탐색 가능.
- DFS: 그래프 탐색 알고리즘. 백트래킹이 가능.
- 위상 정렬: 사이클이 없는 방향 그래프에서 노드를 특정 순서로 방문하는 알고리즘
- 트라이: 하나의 문자를 Node(String, Map<char,Node>)로 생각하여 문자열을 트리로 관리하는 알고리즘.
- 플로이드 워셜: 음의 사이클이 없는 모든 노드 쌍에 대한 최단 거리 탐색 알고리즘으로 O(n^3)의 시간복잡도.
- 다익스트라: 방향그래프에서 한 정점에서 다른 모든 정점까지의 최단 거리를 탐색하는 알고리즘. O(ElogE)의 시간복잡도를 가지며, 음의 가중치나 사이클이 존재하는 경우 사용할 수 없다.
- 크루스칼 알고리즘: 모든 노드를 사이클이 없이 최소 비용으로 연결하는 알고리즘. 시간 복잡도는 O(ElogE)이며, Union-Find를 이용한다. (find(x)==find(y)면, 사이클이 존재하는 것으로 판단)
- Union-Find: 여러 노드를 집합으로 표현하는 알고리즘으로 같은 집합인지 아닌지, 사이클이 존재하는지 등을 위해 사용한다.



